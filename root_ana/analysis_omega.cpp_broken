#include <iostream>

#include "analysis_omega.h"
//#include "cut.h"

using namespace std;

/*--------------------------------------------------*/

Analysis_omega::Analysis_omega() {


}

/*--------------------------------------------------*/

Analysis_omega::Analysis_omega(ReadFile::efficiency_profile eff_struc) {


	
	eff_file = "list.settings.omega";
	off_file = "offset.dat";
// 
// 	cout << off_file << "sdafasfs" << endl;

	eff_ana = eff_struc;
	Init();


	graph_yield_check = new TGraphErrors();
	mm_peak_check = new TGraphErrors();

	yield_setting     = 0.0;
	yield_setting_err = 0.0;

	chain = new TChain();
	list = new TList();

	coin_beta_check_offset_setting = new TH2F("coin_beta_check_offset", "coin_beta_check", 200, -15, 15,  200, 0, 2);

	diamond_setting = new TMultiGraph();


}


/*--------------------------------------------------*/
/// Analysis for Heep 
void Analysis_omega::Omega_anna(Int_t run_itt) {
 
 	cout << "Analyzing Omega data !" << endl;
 
 	cout << " sdaf " << run_itt << endl;
 
  	run_tree = Create_File();
//  
  	Para_Run_Def(run_itt);
// 
 	Load_Data_Tree();

 	out_dir->cd();

// 
// 	Setting all offsets and parameters
// 
// 	Set_Coin_Bin(150);
// 	Set_Coin_Max(10);
// 	Set_Coin_Min(-20);
// 
//  	Double_t array_temp[6] = {-0.01293, -0.01293, -0.01293, -0.01293, -0.01293, -0.01293};
//  	Double_t array_temp[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
// 
// 	Set_Expected_MM(0.0);
// 	Set_MM_Offset(array_temp);
//      
  	coin_center = Analysis::Get_Coin_Center();
// 
// 
 	Define_Cuts();
// 
//	Missing_Mass_Plot();
// 
// 

//	TH2F* t_phi_check = new TH2F("t_phi_check", "t_phi_check", 65, 0, 6.5,  50, 0, 0.5);
//	data_tree_in->Draw("t:phi_pq>>t_phi_check", all_coin_cut, "goff");
// 
// 	TH2F* coin_beta_check = new TH2F("coin_beta_check", "coin_beta_check", 300, -20, 10,  150, 0, 2);
//  	data_tree_in->Draw("hsbeta:cointime>>coin_beta_check", all_coin_cut, "goff");
// 
// 	data_tree_in->Draw("hsbeta:cointime>>coin_beta_check", all_coin_cut, "goff");

// 
// 

	beta_cut                   = 0.1;
	gradi                      = 1./9.;	
	global_centered_hsbeta_cut = -0.1;

	
	rand_early_l = 9.3;
	rand_early_r = 3.4;
	rand_late_l = 5.1;
	rand_late_r = 13.6;  


	cointime_cut_l = 1.1;  
	cointime_cut_r = 1;  

	top_limit = 0.7;
	bot_limit = 0.6;


	random_real_ratio = (abs(rand_late_l - rand_late_r) + abs(rand_early_l-rand_early_r))/(cointime_cut_l + cointime_cut_r);


	// Target thickness difference between the dummy target and Loop 1 hydrogen target
	dummy_correction = 0.142;

	hsbeta_center = GetBetaCenter();

// 	Calculate_Yield(coin_beta_check, global_centered_hsbeta_cut);
 


 

//	data_tree_in->Draw(offset_str + ">>coin_beta_check_offset", HMS_cut() + "&&" + SOS_cut() + "&&" + Heep_PID_Cut(), "goff");

// 
// 
// 	cout << coin_bin <<  "       " << coin_max << "    " << coin_min << endl;
// 
// 	cout << "Now analyzing " << target << " Target Heep Run #" << run_num << ": coin center=" 
// 		 << coin_center << endl;
// 
// 	coin_all  = new TH1F("all", "all", coin_bin, coin_min, coin_max);
// 
// 	cout << Get_kset() << endl;
// 
// 	coin_center = Get_Coin_Center();
// 
// 	all_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + PID_cut() + " && " + Cointime_all(coin_center) + " && " + Diamond_cut() + " && " + Missingmass_cut(miss_mass_offset[kset]) + " && " + Set_t_limit(t_min, t_max);
// 
// 	cout << "___________________" << endl << endl;
// 
// 	cout << coin_center << "   " << Cointime_all(coin_center) << endl;
// 
// 	all_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + PID_cut() + " && "  + Cointime_all(coin_center);
// 
// 	cout << "why this is not working? " << all_coin_cut << endl;
// 
// 	data_tree_in->Draw("cointime>>all",  all_coin_cut, "goff");
// 
// 	coin_all->Write("aaaa");
// 

// 	Para_Run_Clean();




// 	/*--------------------------------------------------*/
// 	Plot to check: missmass, W, t, EXP/SIM, Q2, th_pq,
// 				   phi_pq, PmPar, PmPer, PmOop, hsdelta, hsytar,
// 					   hsyptar, hsxptar, ssdelta, ssytar, ssyptar, ssxptar

	Calculate_Yield_Direct();

	Check_Plot_Out("missmass");
	Check_Plot_Out("W");

	Check_Plot_Out("hsdelta");
	Check_Plot_Out("t");
	Check_Plot_Out("Q2");
	Check_Plot_Out("th_pq");
	Check_Plot_Out("phi_pq");
	Check_Plot_Out("Pmpar");
	Check_Plot_Out("Pmper");
	Check_Plot_Out("Pmoop");
	Check_Plot_Out("hsytar");
	Check_Plot_Out("hsyptar");
	Check_Plot_Out("hsxptar");
	Check_Plot_Out("ssdelta");
	Check_Plot_Out("ssytar");
	Check_Plot_Out("ssyptar");
	Check_Plot_Out("ssxptar");
	Check_Plot_Out("cointime");
 
// 	Check_Plot_Out("hsbeta", "cointime");


	Check_MissingMass_Peak();

//	t_phi_check->Write("t_phi_check");

//	coin_beta_check->Write("coin_beta_check");

//	delete t_phi_check;
//	delete coin_beta_check;




// delete coin_beta_check_offset;

//	File_Clean();

//  data_tree_in->SetName("111");

//	Correct_Offset_Tree();

//
//
//
//
//
//
//


//	TH2F* coin_beta_check_offset = new TH2F("coin_beta_check_offset", "coin_beta_check", 150, -15, 15,  150, 0, 2);

	TH2F* coin_beta_check_offset = new TH2F(*coin_beta_check_offset_setting);

	TString offset_str;

	if (coin_center < 0){
		offset_str.Form("hsbeta:cointime+%f", abs(coin_center));
	} else { 
		offset_str.Form("hsbeta:cointime-%f", coin_center);
	} 

//	cout << coin_center_off << "     " << beta_center_off << "     " << offset_str << endl;

	data_tree_in->Draw(offset_str + ">>coin_beta_check_offset", all_coin_cut , "goff");

	coin_beta_check_offset->Write("coin_beta_check_offset");

	coin_beta_check_offset_setting->Add(coin_beta_check_offset);



	Correct_Offset_Tree();



	list->Add(data_tree_in_cl);


 	delete data_tree_in;
 	file_in->Close();
 	delete file_in;
// 



// 	chain->Add(Get_Current_Run_File()+"/h9500");

}


/*--------------------------------------------------*/
/// Dufine cut

void Analysis_omega::Define_Cuts() {

//	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Heep_PID_Cut() + " && " + Cointime_all(coin_center) + "  && "+ Missingmass_heep_cut();

//	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Heep_PID_Cut() + " && "+ Missingmass_heep_cut();

	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Omega_PID_cut();

//	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Heep_PID_Cut() + " && " + Cointime_all(coin_center);

//	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Heep_PID_Cut() + " && " + Cointime_all(coin_center) + " && " + T_heep_cut();
//	all_coin_cut = HMS_cut() + " && "+ SOS_cut()  + " && " + Heep_PID_Cut();

//	real_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + Heep_PID_Cut() + " && " + Cointime_primary_cut(coin_center);
//	rand_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + Heep_PID_Cut() + " && " + Cointime_random_cut(coin_center);


//	real_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + Omega_PID_cut() + " && " + Cointime_primary_cut(coin_center);

//	rand_coin_cut = HMS_cut() + " && "+ SOS_cut() + " && " + Omega_PID_cut() + " && " + Cointime_random_cut(coin_center);



// 	diamond_cut_245 = new TCutG("diamond_cut_245",4);
// 
// 	diamond_cut_245->SetVarX("Q2");
// 	diamond_cut_245->SetVarY("W");
// 
//   	diamond_cut_245->SetPoint(0, 1.84, 2.39);
//    	diamond_cut_245->SetPoint(1, 2.4,  2.28);
//    	diamond_cut_245->SetPoint(2, 3.13, 2.00);
//    	diamond_cut_245->SetPoint(3, 2.5,  2.15);
//    	diamond_cut_245->SetPoint(4, 1.84, 2.39);
//  
// 
// 
// 
// 	diamond_cut_160 = new TCutG("diamond_cut_160",4);
// 
// 	diamond_cut_160->SetVarX("Q2");
// 	diamond_cut_160->SetVarY("W");
// 
//   	diamond_cut_160->SetPoint(0, 1.17, 2.36 );
//    	diamond_cut_160->SetPoint(1, 1.58, 2.27 );
//    	diamond_cut_160->SetPoint(2, 2.08, 2.055);
//    	diamond_cut_160->SetPoint(3, 1.62, 2.162);
//    	diamond_cut_160->SetPoint(4, 1.17, 2.36);
//  


// //	exit(0);
// 	 
//      
//     if (Get_Q2() == Float_t(1.60)) {
// 		
// 		diamond_cut = (TCutG*) diamond_cut_160->Clone();
// 
// 		cout << Get_Q2() << endl;
// 
// 	} else if (Get_Q2() == Float_t(2.45)) {
// 
// 		diamond_cut = (TCutG*) diamond_cut_245->Clone();
// 		cout << Get_Q2() << endl;
// 
// 	} 


//	exit(0);
	
	diamond_cut = new TCutG("diamond_cut",4);

    diamond_cut->SetVarX("Q2");
	diamond_cut->SetVarY("W");

    if (Get_Q2() == Float_t(1.60)) {

		diamond_cut_160->SetPoint(0, 1.17, 2.36 );
	 	diamond_cut_160->SetPoint(1, 1.58, 2.27 );
	 	diamond_cut_160->SetPoint(2, 2.08, 2.055);	
	 	diamond_cut_160->SetPoint(3, 1.62, 2.162);
	 	diamond_cut_160->SetPoint(4, 1.17, 2.36);

		cout << Get_Q2() << endl;

	} else if (Get_Q2() == Float_t(2.45)) {

	  	diamond_cut->SetPoint(0, 1.84, 2.39);
	   	diamond_cut->SetPoint(1, 2.4,  2.28);
	   	diamond_cut->SetPoint(2, 3.13, 2.00);
	   	diamond_cut->SetPoint(3, 2.5,  2.15);
	   	diamond_cut->SetPoint(4, 1.84, 2.39);

		cout << Get_Q2() << endl;

	} 
	


	






}

// 
// 
// 
// 
// 
/*--------------------------------------------------*/
/// Calculate the efficiency

Int_t Analysis_omega::Calculate_Yield(TH2F* hist_target, Float_t hsbeta_limit) {

// 	float x_mean = hist_target->GetMean(1);

 	float x_mean = coin_center;

//	cout << Get_Run_Num()<< "     " << coin_center << endl; 
//	exit(0);

 	float y_mean = hist_target->GetMean(2);

	coin_center_off = x_mean;
	beta_center_off = y_mean;

// 
//	float x_mean = coin_center;
//	float y_mean = hist_target->GetMean(2);

	float y_max  = hist_target->GetYaxis()->GetXmax();
	float y_min  = hist_target->GetYaxis()->GetXmin();

	/*--------------------------------------------------*/
	Int_t good_events_beta_cut = hist_target->Integral(hist_target->GetXaxis()->FindBin(x_mean-cointime_cut_l), 
			hist_target->GetXaxis()->FindBin(x_mean + cointime_cut_r), 
			hist_target->GetYaxis()->FindBin(hsbeta_limit), 
			hist_target->GetYaxis()->FindBin(y_max)); 

	Int_t random_late_beta_cut = hist_target->Integral(hist_target->GetXaxis()->FindBin(x_mean + rand_late_l), 
			hist_target->GetXaxis()->FindBin(x_mean + rand_late_r), 
			hist_target->GetYaxis()->FindBin(hsbeta_limit), 
			hist_target->GetYaxis()->FindBin(y_max));

	Int_t random_early_beta_cut = hist_target->Integral(hist_target->GetXaxis()->FindBin(x_mean - rand_early_l), 
			hist_target->GetXaxis()->FindBin(x_mean - rand_early_r), 
			hist_target->GetYaxis()->FindBin(hsbeta_limit), 
			hist_target->GetYaxis()->FindBin(y_max)); 


	Int_t tail_count_good  = 0;
	Int_t tail_count_early = 0;
	Int_t tail_count_late  = 0;

	Int_t blank  = 0;
	
	Float_t top_good;
	Float_t down_good;

	Float_t top_early;
	Float_t down_early;

	Float_t top_late;
	Float_t down_late;



	for (int j = 0; j < hist_target->GetYaxis()->GetNbins(); j++) {
		for (int i = 0; i < hist_target->GetXaxis()->GetNbins(); i++) {

				top_good  = Calculate_miss_x (x_mean+cointime_cut_r, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));

				down_good = Calculate_miss_x (x_mean-cointime_cut_l, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));

				top_early  = Calculate_miss_x (x_mean-rand_early_r, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));
				down_early = Calculate_miss_x (x_mean-rand_early_l, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));

				top_late  = Calculate_miss_x (x_mean+rand_late_r, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));

				down_late = Calculate_miss_x (x_mean+rand_late_l, global_centered_hsbeta_cut, hist_target->GetYaxis()->GetBinCenter(j));


				if ( hist_target->GetYaxis()->GetBinCenter(j) > -0.6 && 
					 hist_target->GetYaxis()->GetBinCenter(j) < global_centered_hsbeta_cut) {

					if ( hist_target->GetXaxis()->GetBinCenter(i) < top_good &&  
						 hist_target->GetXaxis()->GetBinCenter(i) > down_good  ) {

//   						 cout << "top and down check "  <<  hist_target->GetYaxis()->GetBinCenter(j) <<  "  "
// 							 << hist_target->GetXaxis()->GetBinCenter(i) << "  " << top_good << "  " << down_good
// 							 << "  "  << hist_target->GetBinContent(i, j) << endl;			
// 
						 tail_count_good = tail_count_good + hist_target->GetBinContent(i, j);

					} else if (hist_target->GetXaxis()->GetBinCenter(i) < top_early &&  
						 hist_target->GetXaxis()->GetBinCenter(i) > down_early  ) {

//   						 cout << "top and down check "  <<  hist_target->GetYaxis()->GetBinCenter(j) <<  "  "
// 							 << hist_target->GetXaxis()->GetBinCenter(i) << "  " << top_early << "  " << down_early
// 							 << "  "  << hist_target->GetBinContent(i, j) << endl;			
// 
						 tail_count_early = tail_count_early + hist_target->GetBinContent(i, j);

					} else if (hist_target->GetXaxis()->GetBinCenter(i) < top_late &&  
						 hist_target->GetXaxis()->GetBinCenter(i) > down_late  ) {

//   						 cout << "top and down check "  <<  hist_target->GetYaxis()->GetBinCenter(j) <<  "  "
// 							 << hist_target->GetXaxis()->GetBinCenter(i) << "  " << top_late << "  " << down_late
// 							 << "  "  << hist_target->GetBinContent(i, j) << endl;			

						 tail_count_late = tail_count_late+ hist_target->GetBinContent(i, j);

					} else {
						blank = blank + hist_target->GetBinContent(i, j);		
					}

			}
		}
    }


	Int_t good_events_total  = good_events_beta_cut + tail_count_good;
	Int_t random_early_total = random_late_beta_cut + tail_count_late;
	Int_t random_late_total  = random_early_beta_cut + tail_count_early;

	/*--------------------------------------------------*/

	if (is_run_dummy) {

		cout <<" dummy Correction " << endl;  
		good_events_total  = dummy_correction * good_events_total;
        random_early_total = dummy_correction * random_early_total;
        random_late_total  = dummy_correction * random_late_total;

	} 

	yield = (float) good_events_total - ((float)random_early_total + (float)random_late_total)/random_real_ratio;;

	cout << "BB yield           " << yield << endl;

	float real_err = 0.0;
	float rand_err = 0.0;

// 	real_err = sqrt((float)good_events_total);
// 	rand_err = sqrt((float)random_early_total + (float)random_late_total)/random_real_ratio;

	if (is_run_dummy) {
		rand_err = sqrt((float)random_early_total + (float)random_late_total) * dummy_correction / random_real_ratio;
	} else { 
		rand_err = sqrt((float)random_early_total + (float)random_late_total) / random_real_ratio;
	}

 	if (is_run_dummy) {
		real_err = sqrt((float)good_events_total) * dummy_correction;
	} else { 
		real_err = sqrt((float)good_events_total);
	}

	yield_err = sqrt( pow(real_err,2) + pow(rand_err, 2) );

//	yield_err = 0.0;

/*--------------------------------------------------*/
/*--------------------------------------------------*/
// 	yield_setting = yield_setting + yield/Get_Total_Eff();
// 	charge_setting = charge_setting + Get_Charge();


//	acccc_temp_setting = acccc_temp_setting + acccc_temp;

	yield_setting     = yield_setting + yield;
// 	charge_setting = charge_setting + Get_Charge()*Get_Total_Eff();

	yield_setting_err = yield_setting_err + pow(yield_err,2);



/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Yield Calculation Example
// // 	yield_setting_err = yield_setting_err/pow(yield_setting, 2)  + errrr_temp/pow(acccc_temp, 2);
// // 
// // 	yield_setting     = yield_setting / acccc_temp ;
// //  yield_setting_err =  yield_setting * sqrt(yield_setting_err);
// // 
// // 	yield_setting     = yield_setting / 1000.;
// // 	yield_setting_err = yield_setting_err / 1000.;
/*--------------------------------------------------*/
/*--------------------------------------------------*/


/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Calculate Normalized yield and error run by run

	Double_t run_acc_err, run_acc;

	run_acc = Get_Charge()*Get_Total_Eff();

	run_acc_err = pow(Get_Charge_Err(), 2) + pow(Get_Total_Eff_Err(), 2); 

	yield_err = pow(yield_err,2)/pow(yield, 2) + run_acc_err;

	yield = yield / run_acc;
	
	yield_err = yield * sqrt(yield_err);

	yield = yield/1000;

	yield_err = yield_err/1000;

	graph_yield_check->SetPoint(graph_yield_check->GetN(), Get_Run_Num(), yield);

	graph_yield_check->SetPointError(graph_yield_check->GetN()-1, 0, yield_err);




	cout << "Yield:   " << yield  
//		 << "   Yield Error:  " << yield_err << endl 
// 		 << random_early_total << "    " << pow(sqrt(random_early_total)/4,2) << endl 
// 		 << random_late_total << "    " << pow(sqrt(random_late_total)/4,2) << endl
		 << "     Efficiency " << Get_Total_Eff()
		 << "     Charge " << Get_Charge() 
		 << "     acccc " << acccc_temp << endl << endl;


	run_tree->Fill();

	Print_out_data();

	return 0;

}




/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// 





Int_t Analysis_omega::Calculate_Yield_Direct() {

 	float x_mean = coin_center;
// 	float y_mean = hist_target->GetMean(2);
 	float y_mean = hsbeta_center;


	cout << hsbeta_center << endl;

	// exit(0);	

	float y_center = y_mean;

/*--------------------------------------------------*/

	coin_cut = new TCutG("coin_cut",6);

	TString coin_str;

	if (coin_center < 0){
		coin_str.Form("cointime+%f", abs(coin_center));
	} else { 
		coin_str.Form("cointime-%f", coin_center);
	} 

	TString hsbeta_str;
//	hsbeta_str.Form("hsbeta-%f", y_mean);

	hsbeta_str = "hsbeta";

	coin_cut->SetVarX(coin_str);
	coin_cut->SetVarY(hsbeta_str);




   	coin_cut->SetPoint(0, cointime_cut_r,  y_center + top_limit);
   	coin_cut->SetPoint(1, cointime_cut_r,  y_center + global_centered_hsbeta_cut);
   	coin_cut->SetPoint(2, Calculate_tail_x (cointime_cut_r,  y_center), y_center-bot_limit);
   	coin_cut->SetPoint(3, Calculate_tail_x (-cointime_cut_l, y_center),y_center-bot_limit);
   	coin_cut->SetPoint(4, -cointime_cut_l, y_center + global_centered_hsbeta_cut);
   	coin_cut->SetPoint(5, -cointime_cut_l, y_center + top_limit);
   	coin_cut->SetPoint(6, cointime_cut_r,  y_center + top_limit);

/*--------------------------------------------------*/

	rand_early_cut = new TCutG("rand_early_cut",6);

	rand_early_cut->SetVarX(coin_str);
	rand_early_cut->SetVarY(hsbeta_str);

	rand_early_cut->SetPoint(0, -rand_early_r, y_center + top_limit);
	rand_early_cut->SetPoint(1, -rand_early_r, y_center + global_centered_hsbeta_cut);
   	rand_early_cut->SetPoint(2, Calculate_tail_x (-rand_early_r, y_center), y_center-bot_limit);
   	rand_early_cut->SetPoint(3, Calculate_tail_x (-rand_early_l, y_center), y_center-bot_limit);
	rand_early_cut->SetPoint(4, -rand_early_l, y_center + global_centered_hsbeta_cut);
	rand_early_cut->SetPoint(5, -rand_early_l, y_center + top_limit);
   	rand_early_cut->SetPoint(6, -rand_early_r, y_center + top_limit);

/*--------------------------------------------------*/

	rand_late_cut  = new TCutG("rand_late_cut", 6);

	rand_late_cut->SetVarX(coin_str);
	rand_late_cut->SetVarY(hsbeta_str);

	rand_late_cut->SetPoint(0, rand_late_r, y_center + top_limit);
	rand_late_cut->SetPoint(1, rand_late_r, y_center + global_centered_hsbeta_cut);
   	rand_late_cut->SetPoint(2, Calculate_tail_x(rand_late_r, y_center), y_center-bot_limit);
   	rand_late_cut->SetPoint(3, Calculate_tail_x(rand_late_l, y_center), y_center-bot_limit);
 	rand_late_cut->SetPoint(4, rand_late_l, y_center + global_centered_hsbeta_cut);
 	rand_late_cut->SetPoint(5, rand_late_l, y_center + top_limit);
 	rand_late_cut->SetPoint(6, rand_late_r, y_center + top_limit);

/*--------------------------------------------------*/

	TString offset_str;

	if (coin_center < 0){
//		offset_str.Form("hsbeta-%f:cointime+%f", y_mean, abs(coin_center));
		offset_str.Form("hsbeta:cointime+%f", abs(coin_center));
	} else { 
//		offset_str.Form("hsbeta-%f:cointime-%f", y_mean, coin_center);
		offset_str.Form("hsbeta:cointime+%f", abs(coin_center));
	} 

/*--------------------------------------------------*/

	TCanvas* v1 = new TCanvas();
	
// 	v1->Update();
// 
//	data_tree_in->Draw(offset_str, "(coin_cut || rand_early_cut || rand_late_cut) && " + all_coin_cut);
	data_tree_in->Draw(offset_str, "(coin_cut || rand_early_cut || rand_late_cut)  &&" + all_coin_cut);
 
 	coin_cut->Draw("Lsame");
 	rand_early_cut->Draw("Lsame");
 	rand_late_cut->Draw("Lsame");

	v1->Update();
	v1->Write("testtest");	
 
	data_tree_in->Draw(offset_str, "coin_cut  &&" + all_coin_cut, "P");
 	TGraph* coin_gr = (TGraph*)gPad->GetPrimitive("Graph");
	TGraph* coin_gr_clone = (TGraph*)coin_gr->Clone();
	Int_t good_events_total = coin_gr->GetN(); 

	data_tree_in->Draw(offset_str, "rand_early_cut  &&" + all_coin_cut, "P");
 	TGraph* rand_early_gr = (TGraph*)gPad->GetPrimitive("Graph");
	TGraph* rand_early_clone = (TGraph*)rand_early_gr->Clone();
	Int_t random_early_total = rand_early_gr->GetN(); 

	data_tree_in->Draw(offset_str, "rand_late_cut  &&" + all_coin_cut, "P");
 	TGraph *rand_late_gr = (TGraph*)gPad->GetPrimitive("Graph");
	TGraph* rand_late_clone = (TGraph*)rand_late_gr->Clone();
	Int_t random_late_total = rand_late_gr->GetN(); 

 	v1->Update();

	coin_gr_clone->SetMarkerColor(2);
	coin_gr_clone->Draw("AP");
		
	v1->Update();

	coin_gr_clone->GetXaxis()->SetLimits(-15.0, 15.0);
//	coin_gr_clone->GetYaxis()->SetLimits( -1.0,  1.0);

	coin_gr_clone->SetMaximum(2.0);
	coin_gr_clone->SetMinimum(0.0);

	v1->Update();

	rand_early_clone->SetMarkerColor(6);
	rand_early_clone->Draw("Psame");

	rand_late_clone->SetMarkerColor(4);
	rand_late_clone->Draw("Psame");
	
 	coin_cut->SetLineColor(2); 
 	coin_cut->Draw("Lsame"); 

 	rand_early_cut->SetLineColor(6); 
 	rand_early_cut->Draw("Lsame");
	
 	rand_late_cut->SetLineColor(4); 
 	rand_late_cut->Draw("Lsame");

	v1->Update();
	v1->Write("hebeta_cointime");

	cout << "/*--------------------------------------------------*/" << endl;
	cout << good_events_total << endl; 
	cout << random_early_total << endl; 
	cout << random_late_total << endl; 
	cout << "/*--------------------------------------------------*/" << endl;

	yield = (float) good_events_total - ((float)random_early_total + (float)random_late_total)/random_real_ratio;;

	cout << "BB yield           " << yield << endl;

	float real_err = 0.0;
	float rand_err = 0.0;

	if (is_run_dummy) {
		rand_err = sqrt((float)random_early_total + (float)random_late_total) * dummy_correction / random_real_ratio;
	} else { 
		rand_err = sqrt((float)random_early_total + (float)random_late_total) / random_real_ratio;
	}

 	if (is_run_dummy) {
		real_err = sqrt((float)good_events_total) * dummy_correction;
	} else { 
		real_err = sqrt((float)good_events_total);
	}

	yield_err = sqrt( pow(real_err,2) + pow(rand_err, 2) );

//	yield_err = 0.0;

/*--------------------------------------------------*/
/*--------------------------------------------------*/
// 	yield_setting = yield_setting + yield/Get_Total_Eff();
// 	charge_setting = charge_setting + Get_Charge();


//	acccc_temp_setting = acccc_temp_setting + acccc_temp;

	yield_setting     = yield_setting + yield;
// 	charge_setting = charge_setting + Get_Charge()*Get_Total_Eff();

	yield_setting_err = yield_setting_err + pow(yield_err,2);



/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Yield Calculation Example
// // 	yield_setting_err = yield_setting_err/pow(yield_setting, 2)  + errrr_temp/pow(acccc_temp, 2);
// // 
// // 	yield_setting     = yield_setting / acccc_temp ;
// //  yield_setting_err =  yield_setting * sqrt(yield_setting_err);
// // 
// // 	yield_setting     = yield_setting / 1000.;
// // 	yield_setting_err = yield_setting_err / 1000.;
/*--------------------------------------------------*/
/*--------------------------------------------------*/


/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Calculate Normalized yield and error run by run

	Double_t run_acc_err, run_acc;

	run_acc = Get_Charge()*Get_Total_Eff();

	run_acc_err = pow(Get_Charge_Err(), 2) + pow(Get_Total_Eff_Err(), 2); 

	yield_err = pow(yield_err,2)/pow(yield, 2) + run_acc_err;

	yield = yield / run_acc;
	
	yield_err = yield * sqrt(yield_err);

	yield = yield/1000;

	yield_err = yield_err/1000;

	graph_yield_check->SetPoint(graph_yield_check->GetN(), Get_Run_Num(), yield);

	graph_yield_check->SetPointError(graph_yield_check->GetN()-1, 0, yield_err);

	cout << "Yield:   " << yield  
//		 << "   Yield Error:  " << yield_err << endl 
// 		 << random_early_total << "    " << pow(sqrt(random_early_total)/4,2) << endl 
// 		 << random_late_total << "    " << pow(sqrt(random_late_total)/4,2) << endl
		 << "     Efficiency " << Get_Total_Eff()
		 << "     Charge " << Get_Charge() 
		 << "     acccc " << acccc_temp << endl << endl;


	run_tree->Fill();

	Print_out_data();


	v1->cd();




	data_tree_in->Draw("W:Q2", "coin_cut   && " + all_coin_cut, "P");
 
	TGraph *w_q2_tmp = (TGraph*)gPad->GetPrimitive("Graph");	
	TGraph *w_q2_gr = (TGraph*)w_q2_tmp->Clone();	

	v1->Write("W_Q2");

// 	TString ttl;
// 	
// 	ttl.Form("%i", Get_Run_Num());
// 
// 
// 	w_q2_gr->SetName(ttl);
// 	w_q2_gr->SetTitle(ttl);

 
	diamond_setting->Add(w_q2_gr);



	data_tree_in_cl = data_tree_in->CopyTree("(coin_cut || rand_early_cut || rand_late_cut) && " + all_coin_cut);


	delete v1;

}


/*--------------------------------------------------*/
/*--------------------------------------------------*/

void Analysis_omega::Print_out_data() {

	out_dir->cd();

	run_tree->Write("yield");
	run_tree->SetName("tree_out");

	yield = 0.0;

	yield_err = 0.0;





}


/*--------------------------------------------------*/
/*--------------------------------------------------*/
void Analysis_omega::Yield_Out() {


	cout << "Check Error: " << yield_setting_err/pow(yield_setting, 2) << "      " 
		 <<  errrr_temp/pow(acccc_temp, 2) << endl;

	yield_setting_err = yield_setting_err/pow(yield_setting, 2)  + errrr_temp/pow(acccc_temp, 2);

	yield_setting     = yield_setting / acccc_temp ;
  	yield_setting_err =  yield_setting * sqrt(yield_setting_err);

	yield_setting     = yield_setting / 1000.;
	yield_setting_err = yield_setting_err / 1000.;

	cout << "Total yield:       " << yield_setting     << endl;
	cout << "Total yield Error: " << yield_setting_err << endl;
	cout << "Total charge:      " << charge_setting    << endl;
	cout << "Effective charge:  " << acccc_temp        << endl;

//	cout << "Real yield Unit :  " << yield_setting / charge_setting /1000 << endl;
//	cout << "Real yield Unit :  " << yield_setting / charge_setting /1000 * 2.4 << endl;
	cout << "Real yield Unit :  " << yield_setting << endl;



	Float_t scale_factor;

	scale_factor = 0.0;

	scale_factor = 1.0/(acccc_temp*1000);

	cout  << " WWWWWWWWWWWW !!!! : " << dummy_correction << endl;

 	if (is_run_dummy)
 		scale_factor =  dummy_correction * scale_factor;


	Set_Scale_Factor(scale_factor);


	file_out_ana->cd();
	SetYield(yield_setting);


// // 	tree_out->Fill();
// // 
// // 	tree_out->Write("yield");
// // 	tree_out->SetName("tree_out");
// // 
// // 	mm_setting->Write("mm_setting"); 
// // 	mm_offset_setting->Write("mm_offset_setting"); 
// // 
// // 	cout << endl << endl;
// // 
// // 	run_tree->Write("yield");
// // 	run_tree->SetName("tree_out");
// //
// //
// 
// // 
// // 
// // 	chain->Draw("missmass", all_coin_cut);


 	Setting_Check_Plot_Out("missmass", 80,  0.45, 1.2  );
 	Setting_Check_Plot_Out("hsdelta",  80, -9,    9    );
 	Setting_Check_Plot_Out("W",        80,  1,    3    );
 	Setting_Check_Plot_Out("t",        80, -1,    1    );
 	Setting_Check_Plot_Out("Q2",       80,  1,    4    );
 	Setting_Check_Plot_Out("th_pq",    80, -0.02, 0.1  );
 	Setting_Check_Plot_Out("phi_pq",   80,  0,    6.5  );
 	Setting_Check_Plot_Out("Pmpar",    80,  0,    0.8  );
 	Setting_Check_Plot_Out("Pmper",    80, -0.15, 0.3  );
 	Setting_Check_Plot_Out("Pmoop",    80, -0.3,  0.3  );
 	Setting_Check_Plot_Out("hsytar",   80, -2.5,  2.5  );
 	Setting_Check_Plot_Out("hsyptar",  80, -0.04, 0.03 );
 	Setting_Check_Plot_Out("hsxptar",  80, -0.04, 0.03 );
 	Setting_Check_Plot_Out("ssdelta",  80, -20,   10   );
 	Setting_Check_Plot_Out("ssytar",   80, -2.5,  2    );
 	Setting_Check_Plot_Out("ssyptar",  80, -0.07, 0.07 );
 	Setting_Check_Plot_Out("ssxptar",  80, -0.05, 0.05 );

//  	Setting_Check_Plot_Out("Em",       600, -0.1,  0.7  );
//  	Setting_Check_Plot_Out("Pm",       800, -0.1,  0.7  );

//	Setting_Check_Plot_Out("W", "Q2");

	Setting_Beta_Cointime_Check();

	TCanvas* cc1 = new TCanvas();


	cc1->cd();

	graph_yield_check->SetMarkerStyle(5);
	graph_yield_check->SetMarkerSize(1.4);
	graph_yield_check->Draw("AP");


	cc1->Update();
	cc1->Write("yield_check");

	cc1->Clear();

	cc1->Update();

	mm_peak_check->SetMarkerStyle(5);
	mm_peak_check->SetMarkerSize(1.4);
	mm_peak_check->Draw("AP");

	cc1->Update();

	cc1->Write("mm_peak_check");

//	Acceptance_check(Get_Acceptence_Vector(), Heep_PID_Cut(), "data");

	Overall_Dia_Plot();

	Yield_output();

// //	file_in->Close();
 	file_out_ana->Close();
// 
// 
// 
 	delete cc1;
 
}



// 
// 
// 
/*--------------------------------------------------*/
/*--------------------------------------------------*/

Float_t Analysis_omega::Calculate_miss_x (Float_t x_boundary, Float_t y_boudary, Float_t y_pos) {

	Float_t x_pos;

	x_pos = x_boundary - (y_boudary - ( y_pos )) / gradi;

	return x_pos;

}




/*--------------------------------------------------*/
/*--------------------------------------------------*/

void Analysis_omega::Check_Plot_Out(TString plot_name) {
	
 	out_dir->cd();
	
//	data_tree_in->Draw(plot_name, all_coin_cut);

//	data_tree_in->Draw(plot_name);

//	data_tree_in->Draw(plot_name, real_coin_cut);

	TCanvas* c5 = new TCanvas(); 

	c5->cd();

	data_tree_in->Draw(plot_name, "coin_cut  &&" + all_coin_cut);
	TH1F *htemp_real_tmp = (TH1F*)gPad->GetPrimitive("htemp");
	TH1F *htemp_real = (TH1F*) htemp_real_tmp->Clone();
	
	htemp_real->SetOption("E");

// 	
// 	htemp_real->SetName(plot_name);
// 	htemp_real->Write(plot_name);
// 
// 	Double_t min  = htemp_real->GetXaxis()->GetXmin();
// 	Double_t max  = htemp_real->GetXaxis()->GetXmax();
// 	Int_t bin_num = htemp_real->GetXaxis()->GetNbins();
// 
// 	// cout << min << "   " << max << "   " << bin_num << endl;
// 
// 	data_tree_in->Draw(plot_name, rand_coin_cut);


	TCanvas* c6 = new TCanvas(); 
	c6->cd();


	
   	TH1F *htemp_rand = (TH1F*)htemp_real->Clone();
  	htemp_rand->Reset();
   	htemp_rand->SetName("htemp_rand");
	
 	data_tree_in->Draw(plot_name + ">> htemp_rand", "(rand_early_cut || rand_late_cut) && u" + all_coin_cut, "goff");

 // 	TH1F *htemp_rand = (TH1F*)gPad->GetPrimitive("htemp");
// // 
// //	htemp_real->SetName(plot_name);
// //	htemp_real->Write(plot_name);

	htemp_rand->SetOption("E");
	
 	htemp_real->Add(htemp_rand, -1/random_real_ratio);
	
 
	htemp_real->Write(plot_name);
	




	delete htemp_real;
	delete htemp_rand;

	delete c5;
	delete c6;


}

// 
// 
// 
void Analysis_omega::Check_Plot_Out(TString plot_var_1, TString plot_var_2) {
	
 	out_dir->cd();

	TCanvas* v3 = new TCanvas();

	v3->cd();	
	data_tree_in->Draw(plot_var_1 + ":" + plot_var_2, all_coin_cut, "P");

 	TGraph *gtemp = (TGraph*)gPad->GetPrimitive("Graph");	
 	gtemp->Draw("P");

	v3->Write(plot_var_1 + "_vs_" + plot_var_2);

	delete gtemp;
	delete v3;

}
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// /*--------------------------------------------------*/
// /*--------------------------------------------------*/
// /*--------------------------------------------------*/
// /// Analysing Heep Simulation Data
// 
// 
// void Analysis_heep::Heep_sim_anna(Int_t run_itt) {
// 
// 
// 	chain = new TChain("chain");
// 
//  	TString sim_file;
//  	sim_file = "list_sim_normfac.dat"; 
// 
// //	cout << setting_str << endl;
//  
// //	ReadFile* rff_sim = new ReadFile("list_sim_normfac.dat");
// 	ReadFile* rff_sim = new ReadFile(sim_file);
// 	sim_ana = rff_sim->sim_pro;
// 
// // 	cout << sim_ana.event_num[run_itt] << endl;
// 
// 	Int_t q2_f, q2_r;
// 	Int_t ebeam_f, ebeam_r;
// 
// 	q2_f    = floor(sim_ana.q2_setting[run_itt]);
// //	q2_r    = sim_ana.q2_setting[run_itt]*1000. - float(q2_f) *1000.;
// 
// 	q2_r    = round(sim_ana.q2_setting[run_itt]*1000.) - q2_f *1000.;
// 
// 	ebeam_f = floor(sim_ana.ebeam[run_itt]);
// 	ebeam_r = round(sim_ana.ebeam[run_itt]*1000.) - ebeam_f *1000.;
// //	ebeam_r = sim_ana.ebeam[run_itt]*1000. - float(ebeam_f) *1000.;
// 
// 
// 	cout <<"MMMMM " << ebeam_r%10 << endl;
// 
// 	if (ebeam_r%10==0) {
// 
// 		ebeam_r = ebeam_r/10;
// 	}
// 
// 	TString sim_in_file_name;
// 	sim_in_file_name.Form("heep_ebeam_%ip%i_q2_%ip%i", ebeam_f, ebeam_r, q2_f, q2_r);
// 	
// 
// 	cout << sim_in_file_name << endl;
// 	
//  	Int_t event = sim_ana.event_num[run_itt];
//  	Double_t normfac = sim_ana.normfac[run_itt];
// 
// //	Int_t event = 5000;
// //	Double_t normfac = 5000;
// 
// //	TString run_number("heep_ebeam_4p21_q2_2p406");
// 	TString run_number;
// 
// 	run_number = sim_in_file_name;
// 
// 	data_file_dir = "sim_data/";
// 	data_file = data_file_dir + run_number + ".root";
// 
// 	if (!rff_sim->File_exist(data_file)) return;
// 
// 	file_in = TFile::Open(data_file);
// 
// 	acceptence_cut = HMS_cut() + " && " + SOS_cut() + " && "+ Missingmass_heep_cut();
// 
// 	data_tree_in = (TTree*)file_in->Get("h666");;
// 
// 	TH1F* mm = new TH1F("mm", run_number + " mm", 100, -0.1, 0.1);
// 	TH1F* mm_org = new TH1F("mm_org", run_number + " mm", 100, -0.1, 0.1);
// 	TH1F* mm_try = new TH1F("mm_try", run_number + " mm", 100, -0.1, 0.1);
// 
// 	sim_selection.Form("%f*Weight*", normfac/event);
// 	
// 	sim_selection = sim_selection + "(" + acceptence_cut + ")";
// 
// //	data_tree_in->Draw("missmass>>mm", sim_selection + "(" + acceptence_cut + ")" , "goff");
// 	data_tree_in->Draw("missmass>>mm", sim_selection, "goff");
// 
// 	data_tree_in->Draw("missmass>>mm_org", acceptence_cut, "goff");
// 	data_tree_in->Draw("missmass>>mm_try", "Weight * (" + acceptence_cut +")", "goff");
// 
// 	cout << endl << "Sum yield: " <<  mm->Integral(0, -1) << endl << endl;;
// 
// 	TCanvas* c1 = new TCanvas();
// 
// 	c1->cd();
// 	mm->Draw();
// 
// 	c1->Update();
// 
// 	c1->Print( run_number + ".eps");
// 
// 	TCanvas* c2 = new TCanvas();
// 	c2->Update();
// 	mm_org->Draw();
// 	c2->Update();
// 
// 	TCanvas* c3 = new TCanvas();
// 	c3->Update();
// 	mm_try->Draw("E");
// 	c3->Update();
// 
// 
// /*--------------------------------------------------*/
// /*--------------------------------------------------*/
// 
// 
// 
// 	cout << "Now Calculating the yield: " << endl;
// 	
// 	// cout << "Get Bins: " << mm->GetNbinsX() << endl;
// 
// 	float yield_raw       = 0.0;		
// 	float yield_weighted  = 0.0;		
// 
// 	float yield_err   = 0.0;		
// 	float yield_err_2 = 0.0;		
// 
// 	for(int i=0; i <= mm->GetNbinsX();i++) {
// 
// //		cout << i << "   " << mm->GetBinContent(i) << endl;
// 		
// 		yield_raw      = yield_raw + mm_org->GetBinContent(i) ;
// 		yield_weighted = yield_weighted + mm->GetBinContent(i) ;
// 		
// 		
// 	}
// 
// 	yield_err = sqrt(yield_err_2);
// 
// 	cout << "Final raw yield : "   << yield_raw << endl;
// 	cout << "Weighed raw yield : " << yield_weighted << endl;
// 
// 
// 
// 	float average_weight = yield_weighted / yield_raw;
// 	float yield_weighted_error = sqrt(yield_raw) * average_weight;
// 
// 	cout << "Average Weight: " << average_weight << endl;
// 	cout << "Garth's Error:  " << yield_weighted_error << endl;
// 
// 
// //	cout << mm_try->Integral(0, -1) << "    " <<  sqrt(mm_try->Integral(0, -1)) * normfac/event << endl;
// 
// 
// 	float upppp = mm_try->Integral(0, -1)* normfac ; 
// 
// 
// //	float pp = upppp / event;
// 
// 	cout << "New yield error : " <<   sqrt(upppp)/event << endl;
// 
// 
// 	chain->Add(data_file + "/h666");
// 
// 
// 
// 	file_out_ana->cd();
// 
// 
// 	Sim_Setting_Check_Plot_Out("missmass", 80, -0.15, 0.15 );
//  	Sim_Setting_Check_Plot_Out("hsdelta",  80, -10,   5    );
//  	Sim_Setting_Check_Plot_Out("W",        80,  0.6,  1.8  );
//  	Sim_Setting_Check_Plot_Out("t",        80, -1,    1    );
//  	Sim_Setting_Check_Plot_Out("Q2",       80,  3,    8    );
//  	Sim_Setting_Check_Plot_Out("thetapq",  80, -0.02, 0.1  );
//  	Sim_Setting_Check_Plot_Out("phipq",    80,  0,    6.5  );
// 	Sim_Setting_Check_Plot_Out("pmpar",    80, -0.5,  0.1  );
// 	Sim_Setting_Check_Plot_Out("pmper",    80, -0.1,  0.3  );
// 	Sim_Setting_Check_Plot_Out("pmoop",    80, -0.05, 0.05 );
//  	Sim_Setting_Check_Plot_Out("hsytar",   80, -2.5,  2.5  );
//  	Sim_Setting_Check_Plot_Out("hsyptar",  80, -0.04, 0.03 );
//  	Sim_Setting_Check_Plot_Out("hsxptar",  80, -0.04, 0.03 );
// 	Sim_Setting_Check_Plot_Out("ssdelta",  80, -20,   10   );
// 	Sim_Setting_Check_Plot_Out("ssytar",   80, -2.5,  2    );
//  	Sim_Setting_Check_Plot_Out("ssyptar",  80, -0.07, 0.07 );
//  	Sim_Setting_Check_Plot_Out("ssxptar",  80, -0.05, 0.05 );
//  	Sim_Setting_Check_Plot_Out("Em",       600, -0.1,  0.7  );
//  	Sim_Setting_Check_Plot_Out("Pm",       800, -0.1,  0.7  );
// 
// 
// 
// 
// 
// 	chain->Draw("Em:missmass", acceptence_cut, "hist");
// 
// 	TH1F* htempp = (TH1F*)gPad->GetPrimitive("htemp");
// 
// 	htempp ->Write("Em_missmass");
// 
// 
// 
// 
// 
// 	TString sim_app_selection;
// 
// 	sim_app_selection.Form("%f*Weight*", normfac/event);
// 	
// 	sim_app_selection = sim_app_selection + "(" + HMS_cut() + " && " + SOS_cut() + ")";
// 
// 
// 	Acceptance_check(Get_Acceptence_Vector(), sim_app_selection, "sim");
// 
// 	yield_setting = yield_weighted;
// 	yield_setting_err = yield_weighted_error;
// 
// 	Yield_output();
// 
// 
// }
// 
// 
// 
// void Analysis_heep::Sim_Setting_Check_Plot_Out(TString plot_name , Int_t bin_num, Double_t lower, Double_t upper) {
// 
// 
// 
// 	TH1F* mm_hist = new TH1F(plot_name, plot_name, bin_num, lower, upper);
// 
// 
//  	chain->Draw(plot_name + ">>" + plot_name, sim_selection);
// 
// //	cout << "SSS :: " << plot_name << endl;
// //	cout << "SSS :: " << plot_name << endl;
// 
// 	if (plot_name == "thetapq") {
// 
// 		plot_name = "th_pq";
// 
// 	} else if (plot_name == "phipq") {
// 
// 		plot_name = "phi_pq";
// 
// 	} else if (plot_name == "pmpar") {
// 
// 		plot_name = "Pmpar";
// 
// 	} else if (plot_name == "pmper") {
// 
// 		plot_name = "Pmper";
// 
// 	} else if (plot_name == "pmoop") {
// 
// 		plot_name = "Pmoop";
// 
// 	}
// 
// 
// 
// 
// 
// 
// 	mm_hist->Write(plot_name);
// 
// 
// // // // 	TString selection_string;
// // // // 
// // // // 	selection_string.Form("%f*(",1/event);
// // // // 	
// // // // 	selection_string = selection_string  + all_coin_cut + ")" ;
// // // // 	
// // // 
// // // //	cout << selection_string << endl; 
// // // 
// // // //	chain->Draw(plot_name);
// // // 	chain->Draw(plot_name, sim_selection);
// // // 
// // // //	data_tree_in->Draw(plot_name, real_coin_cut);
// // // 
// // // 	TH1F *htemp_real = (TH1F*)gPad->GetPrimitive("htemp");
// // // 
// // // 	htemp_real->SetName(plot_name);
// // // 
// // // 	htemp_real->Write(plot_name);
// 
// 
// // 	Double_t min  = htemp_real->GetXaxis()->GetXmin();
// // 	Double_t max  = htemp_real->GetXaxis()->GetXmax();
// // 	Int_t bin_num = htemp_real->GetXaxis()->GetNbins();
// // 
// // 	// cout << min << "   " << max << "   " << bin_num << endl;
// // 
// // 	chain->Draw(plot_name, rand_coin_cut);
// // 	TH1F *htemp_rand = (TH1F*)gPad->GetPrimitive("htemp");
// // 
// //	htemp_real->SetName(plot_name);
// //	htemp_real->Write(plot_name);
// 
// 
// }




/*--------------------------------------------------*/

void Analysis_omega::Setting_Beta_Cointime_Check() {
	
// 	TCanvas* beta_coin_can = new TCanvas();
// 	
// 	TH2F* setting_coin_beta_check = new TH2F("setting_coin_beta_check", "coin_beta_check", 150, -20, 10,  150, 0, 2);
// 
// 	chain->Draw("hsbeta:cointime>>setting_coin_beta_check", all_coin_cut, "goff");
// 
// //	setting_coin_beta_check->Write("coin_beta_check");
// 
// 	beta_coin_can->cd();
// 
// 	setting_coin_beta_check->Draw();
// 
// 	float x_cen = setting_coin_beta_check->GetMean(1);
// 	float y_cen = setting_coin_beta_check->GetMean(2) + global_centered_hsbeta_cut;
// 
//  	DrawGoodBox(x_cen, y_cen);
//  	DrawRandomBox(x_cen, y_cen);
// 
// 	beta_coin_can->Write("coin_beta_check");
// 
// 	delete beta_coin_can;


/*--------------------------------------------------*/
/*--------------------------------------------------*/

// 	TTree *setting_tree = TTree::MergeTrees(list);
// 	
// 	TCanvas* beta_coin_can = new TCanvas();
// // 	
// // 	TH2F* setting_coin_beta_check = new TH2F("setting_coin_beta_check", "coin_beta_check", 150, -20, 10,  150, 0, 2);
// // 
// // 	chain->Draw("hsbeta:cointime>>setting_coin_beta_check", all_coin_cut, "goff");
// // 
// // //	setting_coin_beta_check->Write("coin_beta_check");
// // 
// // 	beta_coin_can->cd();
// // 
// // //	setting_coin_beta_check->Draw();
// // 
// // 	float x_cen = setting_coin_beta_check->GetMean(1);
// // 	float y_cen = setting_coin_beta_check->GetMean(2) + global_centered_hsbeta_cut;
// // 
// // 	setting_coin_beta_check->Draw("scat=0.5");
// // 
// //  	DrawGoodBox(x_cen, y_cen);
// //  	DrawRandomBox(x_cen, y_cen);
// 
// 
// 	float x_cen;
// 	float y_cen;
// 
// 	TH2F* setting_coin_beta_check_cor = new TH2F("setting_coin_beta_check_cor", "", 150, -10, 10,  150, 0, 2);
// 
// 	setting_tree->Draw("hsbeta:ct_corrected>>setting_coin_beta_check_cor", all_coin_cut, "goff");
// 
//  	beta_coin_can->Update();
// 
// 	x_cen = setting_coin_beta_check_cor->GetMean(1);
// 	y_cen = setting_coin_beta_check_cor->GetMean(2) + global_centered_hsbeta_cut;
// 
// 	setting_coin_beta_check_cor->SetMarkerColor(2);
// 
// 	//setting_coin_beta_check_cor->Draw("scat=0.5 same");
// 	setting_coin_beta_check_cor->Draw();
// 
//   	DrawGoodBox(x_cen, y_cen);
//   	DrawRandomBox(x_cen, y_cen);
// 
// 
//     setting_coin_beta_check_cor-> GetYaxis()->SetTitle("hsbeta");
//     setting_coin_beta_check_cor-> GetYaxis()->CenterTitle();
// 
//     setting_coin_beta_check_cor-> GetXaxis()->SetTitle("Coincidence");
//     setting_coin_beta_check_cor-> GetXaxis()->CenterTitle();
// 
// 
// 
// // 	beta_coin_can->Modified();
// 
//  	beta_coin_can->Update();
//  	beta_coin_can->Write("coin_beta_check");
// 
// 	delete beta_coin_can;
// //	delete setting_tree;
// 
/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Dosenot work
//
// 	TH2F *setting_tree = new TH2F(); 
// 	TH2F* coin_temp = (TH2F*) list->FindObject("coin_beta_check");
// 
// //	TH2F* setting_tree = (TH2F*) coin_temp->Clone();
// 
// //	setting_tree->Reset();
// 
// 	list->ls();
// 
// 	coin_temp->GetEntries();


	TCanvas* beta_coin_can = new TCanvas();
	
  	float x_cen;
 	float y_cen;
 
// 	x_cen = coin_beta_check_offset_setting->GetMean(1);
 	x_cen = 0;

 	y_cen = coin_beta_check_offset_setting->GetMean(2) + global_centered_hsbeta_cut;

    coin_beta_check_offset_setting->SetMarkerColor(2);
    coin_beta_check_offset_setting->Draw();
 
   	DrawGoodBox(x_cen, y_cen);
   	DrawRandomBox(x_cen, y_cen);

    coin_beta_check_offset_setting->GetYaxis()->SetTitle("hsbeta");
    coin_beta_check_offset_setting->GetYaxis()->CenterTitle();

    coin_beta_check_offset_setting->GetXaxis()->SetTitle("Coincidence");
    coin_beta_check_offset_setting->GetXaxis()->CenterTitle();

 	beta_coin_can->Update();
 	beta_coin_can->Write("coin_beta_check");


	TCutG *cutg = new TCutG("mycut",1);
	cutg->SetPoint(0,-15,-0.2);
	cutg->SetPoint(1, 15,-0.2);



	TH1D* h11 = coin_beta_check_offset_setting->ProjectionX("cointime_pro", 0, -1, "mycut");

	Double_t h_max = h11->GetMaximum() * 0.75;

	beta_coin_can->cd();
	h11->Draw();

	TLine *line1 = new TLine();
 	line1->SetLineStyle(2);
 	line1->SetLineWidth(1.4);

	line1->DrawLine(rand_late_l,   0, rand_late_l,     h_max);
	line1->DrawLine(rand_late_r,   0, rand_late_r,     h_max);
	line1->DrawLine(-rand_early_l, 0, -rand_early_l, h_max);
	line1->DrawLine(-rand_early_r, 0, -rand_early_r, h_max);

	TLine *line2 = new TLine();
 	line2->SetLineStyle(2);
 	line2->SetLineColor(2);
 	line2->SetLineWidth(1.4);
	line2->DrawLine( cointime_cut_r, 0,  cointime_cut_r, h_max);
	line2->DrawLine(-cointime_cut_l, 0, -cointime_cut_l, h_max);


	beta_coin_can->Update();

	beta_coin_can->Write("cointime_projection");

	delete line1;
	delete line2;

	delete beta_coin_can;




}

// 
// /*--------------------------------------------------*/

void Analysis_omega::Setting_Check_Plot_Out(TString plot_name , Int_t bin_num, Double_t lower, Double_t upper) {

// 
// // 	TString selection_string;
// // 
// // 	selection_string.Form("%f*(",1/(acccc_temp*1000));
// // 	
// // //	selection_string = selection_string  + all_coin_cut + ")" ;
// // 	selection_string = selection_string  + real_coin_cut + ")" ;
// // 
// // 	TH1F* mm_hist_real = new TH1F(plot_name+"_real", plot_name, bin_num, lower, upper);
// // 
// //  	chain->Draw(plot_name + ">>" + plot_name+"_real", selection_string);
// // 
// // // 	chain->Draw(plot_name + ">>" + plot_name+"_real");
// // 
// // 
// // // 
// // // 	TString selection_string1;
// // // 
// // // 	selection_string1.Form("%f*(",1/(acccc_temp*1000));
// // // 	
// // // 	selection_string1 = selection_string1  + rand_coin_cut + ")" ;
// // // 
// // // 	TH1F* mm_hist_rand = new TH1F(plot_name+"_rand", plot_name, bin_num, lower, upper);
// // // 
// // //  	chain->Draw(plot_name + ">>" + plot_name+"_rand", selection_string1);
// // // 
// // // 	mm_hist_real->Add(mm_hist_rand, -0.333333333);
// // // 
// // //	plot_name.ToLower();
// // 
// // 	mm_hist_real->Write(plot_name);
// // 
// // 	delete mm_hist_real;
// 
// 
// 
// 	TTree *setting_tree = TTree::MergeTrees(list);
// 
// 
//  	TH1F* mm_hist_real = new TH1F(plot_name+"_real", plot_name, bin_num, lower, upper);
//  
// 	chain->Draw(plot_name + ">>" + plot_name+"_real", all_coin_cut);
//  
// 
//  	TH1F* mm_hist_rand = new TH1F(plot_name+"_rand", plot_name, bin_num, lower, upper);
//  
//   	chain->Draw(plot_name + ">>" + plot_name+"_rand", all_coin_cut);
// 
// 	TH1F *mm_hist_real_sub = (TH1F*) mm_hist_real->Clone();
//  	mm_hist_real_sub->Add(mm_hist_rand, -(1/random_real_ratio));
// 
// 
// 
// 	Double_t real_bin;
// 	Double_t rand_bin;	
// 	
// 	Double_t real_bin_err;
// 	Double_t rand_bin_err;
// 
// 	Double_t sub_err_2;
// 
// 	Double_t norm_yield;
// 	Double_t norm_yield_err;
// 
// 	for (int i = 1;  i <= mm_hist_real_sub->GetNbinsX(); i++) {
// 		
// //		if ( mm_hist_real_sub->GetBinContent(i) != 0) {
// 
// // // 	yield_setting_err = yield_setting_err/pow(yield_setting, 2)  + errrr_temp/pow(acccc_temp, 2);
// // // 
// // // 	yield_setting     = yield_setting / acccc_temp ;
// // //   	yield_setting_err =  yield_setting * sqrt(yield_setting_err);
// // // 
// // // 	yield_setting     = yield_setting / 1000.;
// // // 	yield_setting_err = yield_setting_err / 1000.;
// 
// 			real_bin = mm_hist_real->GetBinContent(i);
// 			rand_bin = mm_hist_rand->GetBinContent(i);
// 	
// 			Double_t real_bin_err = sqrt(real_bin);
// 			Double_t rand_bin_err = sqrt(rand_bin) / random_real_ratio;
// 	
// 			sub_err_2 = pow(real_bin_err,2) + pow(rand_bin_err,2);
// 
// 
// 			/*--------------------------------------------------*/
// 			/*--------------------------------------------------*/
// 
// 
// 			norm_yield = mm_hist_real_sub->GetBinContent(i);
// 
// 			if (norm_yield == 0) { 
// 
// 
// 			} else {
// 
// 				norm_yield_err = sub_err_2/pow(norm_yield, 2)  + errrr_temp/pow(acccc_temp, 2);
// 
// 			}
// 
// 
// 
// 			norm_yield = norm_yield/acccc_temp;
// 				
// 			norm_yield_err =  norm_yield * sqrt(norm_yield_err);
// 
// 
// 
// 
// 			norm_yield = norm_yield / 1000;
// 			
// 			norm_yield_err = norm_yield_err / 1000;
// 
// 			cout  << i << "   "   <<  mm_hist_real_sub->GetBinCenter(i) << "    "<< norm_yield << endl;
// 			
//  			mm_hist_real_sub->SetBinContent(i, norm_yield);
//  			mm_hist_real_sub->SetBinError(i, norm_yield_err);
// 
// //		}	
// 		 		
// //
// //
// // //		cout << i << endl;		
// // 
// // 		if ( mm_hiyst_real->GetBinContent(i) != 0)
// // 			mm_hist_real->SetBinError(i, 0.1);
// // 
//  	}
// // 
// // 
// //
// //    Double_t scale_fac = 1/(acccc_temp*1000);
// 
// //	mm_hist_real_sub->Scale(scale_fac);
// 
// 	mm_hist_real_sub->SetOption("E");
// 
// 	mm_hist_real_sub->Write(plot_name);
// // 
// 
// 
// //    exit(0);
// 
// 	delete setting_tree;



	TTree *setting_tree = TTree::MergeTrees(list);


 	TH1F* mm_hist_real = new TH1F(plot_name+"_real", plot_name, bin_num, lower, upper);
 
//  	chain->Draw(plot_name + ">>" + plot_name+"_real", real_coin_cut);
  	setting_tree->Draw(plot_name + ">>" + plot_name+"_real", real_coin_cut);
 

 	TH1F* mm_hist_rand = new TH1F(plot_name+"_rand", plot_name, bin_num, lower, upper);
 
//  	chain->Draw(plot_name + ">>" + plot_name+"_rand", rand_coin_cut);
  	setting_tree->Draw(plot_name + ">>" + plot_name+"_rand", rand_coin_cut);


	TH1F *mm_hist_real_sub = (TH1F*) mm_hist_real->Clone();
 	mm_hist_real_sub->Add(mm_hist_rand, -1/random_real_ratio);



	Double_t real_bin;
	Double_t rand_bin;	
	
	Double_t real_bin_err;
	Double_t rand_bin_err;

	Double_t sub_err_2;

	Double_t norm_yield;
	Double_t norm_yield_err;

	for (int i = 1;  i <= mm_hist_real_sub->GetNbinsX(); i++) {
		
//		if ( mm_hist_real_sub->GetBinContent(i) != 0) {

// // 	yield_setting_err = yield_setting_err/pow(yield_setting, 2)  + errrr_temp/pow(acccc_temp, 2);
// // 
// // 	yield_setting     = yield_setting / acccc_temp ;
// //   	yield_setting_err =  yield_setting * sqrt(yield_setting_err);
// // 
// // 	yield_setting     = yield_setting / 1000.;
// // 	yield_setting_err = yield_setting_err / 1000.;

			real_bin = mm_hist_real->GetBinContent(i);
			rand_bin = mm_hist_rand->GetBinContent(i);
	
			Double_t real_bin_err = sqrt(real_bin);
			Double_t rand_bin_err = sqrt(rand_bin) * 1/random_real_ratio;
	
			sub_err_2 = pow(real_bin_err,2) + pow(rand_bin_err,2);




			/*--------------------------------------------------*/
			/*--------------------------------------------------*/


			norm_yield = mm_hist_real_sub->GetBinContent(i);

			if (norm_yield == 0) { 


			} else {

				norm_yield_err = sub_err_2/pow(norm_yield, 2)  + errrr_temp/pow(acccc_temp, 2);

			}



			norm_yield = norm_yield/acccc_temp;
				
			norm_yield_err =  norm_yield * sqrt(norm_yield_err);




			norm_yield = norm_yield / 1000;
			
			norm_yield_err = norm_yield_err / 1000;

//			cout  << i << "   "   <<  mm_hist_real_sub->GetBinCenter(i) << "    "<< norm_yield << endl;
			
 			mm_hist_real_sub->SetBinContent(i, norm_yield);
 			mm_hist_real_sub->SetBinError(i, norm_yield_err);

//		}	
		 		
//
//
// //		cout << i << endl;		
// 
// 		if ( mm_hiyst_real->GetBinContent(i) != 0)
// 			mm_hist_real->SetBinError(i, 0.1);
// 
 	}
// 
// 
//
//    Double_t scale_fac = 1/(acccc_temp*1000);

//	mm_hist_real_sub->Scale(scale_fac);

	mm_hist_real_sub->SetOption("E");

	mm_hist_real_sub->Write(plot_name);
// 


//    exit(0);

	delete setting_tree;








}
// 
// 

// /*--------------------------------------------------*/
// 
// void Analysis_omega::Setting_Check_Plot_Out(TString plot_name) {
// 	
// 	chain->Draw(plot_name, all_coin_cut);
//  	TH1F *htemp = (TH1F*)gPad->GetPrimitive("htemp");
// 	htemp->Write(plot_name);
// 
// }
// 
// 
// 
// void Analysis_omega::Setting_Check_Plot_Out(TString plot_var_1, TString plot_var_2) {
// 	
// 	TCanvas* v3 = new TCanvas();
// 	v3->cd();	
// 
// 	chain->Draw(plot_var_1 + ":" + plot_var_2, all_coin_cut, "P");
// 
//  	TGraph *gtemp = (TGraph*)gPad->GetPrimitive("Graph");	
//  	gtemp->Draw("P");
// 
// 	v3->Write(plot_var_1 + "_vs_" + plot_var_2);
// 
// //	cout << "aasdasd a" << endl;
// 
// 	delete gtemp;
// 	delete v3;
// 
// }
// 
// 



/*--------------------------------------------------*/
/// Plot boxes


void Analysis_omega::DrawGoodBox(float x_center, float y_center) {

//	cout << x_center - 1 << endl; 

	TLine *line1 = new TLine();
 	line1->SetLineWidth(1.4);
 	line1->SetLineColor(2);
	line1->DrawLine(x_center-cointime_cut_l, y_center, x_center - cointime_cut_l, y_center + top_limit);
	line1->DrawLine(x_center+cointime_cut_r, y_center, x_center + cointime_cut_r, y_center + top_limit);
	line1->DrawLine(x_center-cointime_cut_l, y_center, x_center + cointime_cut_r, y_center);

	line1->DrawLine(x_center-cointime_cut_l, y_center, Calculate_tail_x (x_center - cointime_cut_l, y_center ), y_center - bot_limit);
	line1->DrawLine(x_center+cointime_cut_r, y_center, Calculate_tail_x (x_center + cointime_cut_r, y_center ), y_center - bot_limit);


}


// 
void Analysis_omega::DrawRandomBox(float x_center, float y_center) {

	TLine *line1 = new TLine();
 	line1->SetLineStyle(2);
 	line1->SetLineWidth(1.4);
	line1->DrawLine(x_center+rand_late_l, y_center, x_center + rand_late_l, y_center + top_limit);
	line1->DrawLine(x_center+rand_late_r, y_center, x_center + rand_late_r, y_center + top_limit);
	line1->DrawLine(x_center+rand_late_l, y_center, x_center + rand_late_r, y_center);

	line1->DrawLine(x_center+rand_late_l, y_center, Calculate_tail_x (x_center + rand_late_l, y_center ), y_center - bot_limit);
	line1->DrawLine(x_center+rand_late_r, y_center, Calculate_tail_x (x_center + rand_late_r, y_center ), y_center - bot_limit);


	TLine *line2 = new TLine();
 	line2->SetLineStyle(2);
 	line2->SetLineWidth(1.4);
	line2->DrawLine(x_center-rand_early_l, y_center, x_center - rand_early_l, y_center + top_limit);
	line2->DrawLine(x_center-rand_early_r, y_center, x_center - rand_early_r, y_center + top_limit);
	line2->DrawLine(x_center-rand_early_l, y_center, x_center - rand_early_r, y_center);

	line2->DrawLine(x_center-rand_early_r, y_center, Calculate_tail_x (x_center - rand_early_r, y_center), y_center - bot_limit);
	line2->DrawLine(x_center-rand_early_l, y_center, Calculate_tail_x (x_center - rand_early_l, y_center), y_center - bot_limit);

}
// 
// 
// 

Float_t Analysis_omega::Calculate_tail_x (Float_t xx, Float_t yy) {
	
	Float_t xx_tail;

	xx_tail = xx - (yy - (yy - bot_limit)) / gradi;

//	cout << "Calculation Check: "  << xx_tail << "    " << xx << "    " << float (yy - (-0.6)) * gradi << endl;

	return xx_tail;


}

// 
// 
// 

/*--------------------------------------------------*/

void Analysis_omega::Yield_output() {

	static int dummy_count = 0; 
	static int sim_count = 0; 
	static int target_count = 0; 

	
	TString file_name_str;

	file_name_str = file_out_ana->GetName();

//	cout << file_name_str << "    " << file_name_str.Contains("asdummy") << endl;


	if (file_name_str.Contains("dummy") )  {

		if (dummy_count ==0) {
			yield_file_out.open("dummy_yield.txt",std::fstream::out );
			dummy_count++;
		} else {
			yield_file_out.open("dummy_yield.txt",std::fstream::app );
		}


	} else if (file_name_str.Contains("sim")) {

		if (sim_count ==0) {
			yield_file_out.open("sim_yield.txt", std::fstream::out );		
			sim_count++;
		} else {
			yield_file_out.open("sim_yield.txt",std::fstream::app );
		}

	} else {

		if (target_count ==0) {
			yield_file_out.open("target_yield.txt", std::fstream::out );		
			target_count++;
		} else {
			yield_file_out.open("target_yield.txt",std::fstream::app );
		}



	}

	yield_file_out << yield_setting  << "  "<< yield_setting_err << endl;

}

// 
// 
// 
// 
// 
// /*--------------------------------------------------*/
// 
// 
// 
// 
// void Analysis_heep::Acceptance_check(vector<TString> list_vec, TString cut_str, TString data_type) {
// 
// 
// 	vector<TString>::iterator it;
// 
// 	TDirectory* acceptence_dir;
// 
// 	acceptence_dir = file_out_ana->mkdir("acceptence_check");
// 
// 	acceptence_dir->cd();
// 
//   	for (it = list_vec.begin(); it != list_vec.end(); ++it) {
// 
// 		TString tmp;
// 		tmp = *it;
// 
// 		Apt_Setting_Check(tmp, cut_str, data_type);
// 
// //    	cout << "    " << tmp << endl;
// 
// 	}
// 
// //    	cout << ' ' << *it << endl;
// // 
// // 	exit(0);
// 
// }
// 
// 
// /*--------------------------------------------------*/
// /*--------------------------------------------------*/
// 
// void Analysis_heep::Apt_Setting_Check(TString plot_name, TString cut_str, TString data_type) {
// 	
// // 	ssdelta_h     = new TH1F("ssdelta", "ssdelta", 200, -20, 20);
// // 	ssxptar_h     = new TH1F("ssxptar", "ssxptar", 200, -0.05, 0.05);
// // 	ssyptar_h     = new TH1F("ssyptar", "ssyptar", 200, -0.1, 0.1);
// // 
// // 	w_h           = new TH1F("w_h",  "w_h",  200, 0.5, 1.5);
// // 	q2_h          = new TH1F("q2_h", "q2_h", 200, 4, 6);
// // 
// //	sszbeam_h     = new TH1F("sszbeam",  "sszbeam" , 200, -5, 10);
// //
// //
// 
// // w_h           = new TH1F("w_h",  "w_h",  200, 0.5, 1.5)
// 
// 
// 
// 	
// 	TString plot_op_str;
// 	
// 
// 	if (plot_name == "ssxptar") {
// 	
// 		plot_op_str = plot_name + ">> htemp(200, -0.05, 0.05)";	
// 
// 	} else if (plot_name == "ssyptar") {
// 
// 		plot_op_str = plot_name + ">> htemp(200, -0.1, 0.1)";	
//  
// 	} else if (plot_name == "Q2") {
// 
// 		plot_op_str = plot_name + ">> htemp(200, 3, 8)";	
// 
// 	} else if (plot_name == "sszbeam") {
// 
// 		plot_op_str = plot_name + ">> htemp(200, -5, 10)";	
// 
// 	} else if (plot_name == "ssytar") {
// 
// 		plot_op_str = plot_name + ">> htemp(200, -5, 5)";	
// 
// 	} else if (plot_name == "ssdelta") {
// 
// 		plot_op_str = plot_name + ">> htemp(200, -40, 40)";	
// 
// 	} else if (plot_name == "W") {
// 
// 		plot_op_str = plot_name;
// 
// 		if( data_type == "data") {
// 
// 			plot_op_str = "w";
// 
// 		}
// 
//  		plot_op_str = plot_op_str + " >> htemp(200, 0.5, 1.5)";
// 
// 	}  else if (plot_name == "ssxfp") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -20, 15)";
// 
// 	}  else if (plot_name == "ssxpfp") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -0.15, 0.14)";
// 
// 	} else if (plot_name == "missmass") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -0.15, 0.15)";
// 
// 	} else if (plot_name == "hsdelta") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -15, 15)";
// 
// 	} else if (plot_name == "hsxptar") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -0.1, 0.1)";
// 
// 	} else if (plot_name == "hsyptar") {
// 
// 		plot_op_str = plot_name + " >> htemp(200, -0.1, 0.1)";
// 
// 	} else {
// 
// 		plot_op_str = plot_name;
// 
// 	}
// 
// 
// 
// 	// cout << " asdasda    " << cut_str << endl;
// 
// 
// 
// 
//  	chain->Draw(plot_op_str, cut_str);
//  
//    	TH1F* htempp = (TH1F*)gPad->GetPrimitive("htemp");
// // 
// // 
// 	if (data_type == "data") {
// 	
// 		htempp ->Scale(Get_Scale_Factor());
// 
// 	} 
// // 
// // 
// //
// 
// 	cout << plot_name << endl;
// 
//  	htempp->Write(plot_name);
// 
// 	delete htempp;
// 
// 
// }
// 
/*--------------------------------------------------*/

vector<TString> Analysis_omega::Get_Acceptence_Vector() {

	static const TString list_arr[] = { "missmass", "Q2","ssdelta", "ssxfp", "ssxpfp", "ssytar", "ssxptar", "ssyptar", "hsdelta", "hsxptar", "hsyptar"};

	vector<TString> vec (list_arr, list_arr + sizeof(list_arr) / sizeof(list_arr[0]) );

	return vec;

}


/*--------------------------------------------------*/


void Analysis_omega::Check_MissingMass_Peak() {

	TCanvas *c2 = new TCanvas();

	c2->cd();
	
	data_tree_in->Draw("missmass>>htemp(150, 0.5, 1.1)", real_coin_cut);
 	TH1F *htemp_real = (TH1F*)gPad->GetPrimitive("htemp");
	
//	Double_t missing_mass_max = htemp_real->GetMaximum(); 
	Double_t missing_mass_max = 0.783; 

	

	TF1* fit_fun = new TF1("my_function", "gaus");
	TF1* fit_fun_improve = new TF1("my_function_imp", "gaus");


	cout << missing_mass_max << endl;
	cout << missing_mass_max << endl;
	cout << missing_mass_max << endl;
	cout << missing_mass_max << endl;

	fit_fun->SetRange(missing_mass_max-0.025, missing_mass_max+0.025);

	htemp_real->Fit("my_function", "R");


 	fit_fun_improve = new TF1("my_function_imp", "gaus");
 	
 	fit_fun_improve->SetRange(fit_fun->GetParameter("Mean")-0.025, fit_fun->GetParameter("Mean")+0.025);

	htemp_real->Fit("my_function_imp", "R");

	fit_fun_improve->Draw("same");

	c2->Update();

	c2->Write("mm_peak_check");

	mm_peak_check->SetPoint(mm_peak_check->GetN(), Get_Run_Num(), fit_fun_improve->GetParameter("Mean"));	
	mm_peak_check->SetPointError(mm_peak_check->GetN()-1, 0, fit_fun_improve->GetParError(2));	




 	delete htemp_real;
 	delete fit_fun;
 	delete fit_fun_improve;
 
	delete c2;


}


/*--------------------------------------------------*/
/*--------------------------------------------------*/

void Analysis_omega::Correct_Offset_Tree() { 

	Float_t missmass_cor;
	Float_t missmass_org;

	missmass_cor = 1;


    TBranch *mm_cor_branch = data_tree_in_cl->Branch("ct_corrected", &missmass_cor);
    
	data_tree_in_cl->SetBranchAddress("cointime", &missmass_org);

	data_tree_in_cl->SetBranchStatus("*", 0);
	data_tree_in_cl->SetBranchStatus("ct_corrected", 1);


	//TTree* data_tree_clone = (TTree* ) data_tree_in->Clone(0);

	Int_t nentries = data_tree_in_cl->GetEntries();

    for (Int_t i=0; i < nentries; i++) { 

		data_tree_in_cl->SetBranchStatus("cointime", 1);

		data_tree_in_cl->GetEvent(i);

		if (Get_Coin_Center() < 0) { 
			missmass_cor  = missmass_org + abs(Get_Coin_Center()); 
		} else {
			missmass_cor  = missmass_org - Get_Coin_Center(); 
		}


//  		cout << "Org  " << nentries << "   " << Get_Coin_Center() << "    " << missmass_org << endl;
//  		cout << "cor  " << missmass_cor << endl;

		data_tree_in_cl->SetBranchStatus("cointime", 0);

		mm_cor_branch->Fill();

	}


//      tree->GetEvent(i);
// 
//      //  compute variables for new branches and fill these branches
//   ...
//    bnew1->Fill();
//    bnew2->Fill();

	data_tree_in_cl->SetBranchStatus("*", 1);

//	return data_tree_in; 


}








/*--------------------------------------------------*/
/*--------------------------------------------------*/

Double_t Analysis_omega::GetBetaCenter() { 


	TString coin_cut_str;

	coin_cut_str.Form("cointime > %f && cointime <%f", coin_center - cointime_cut_l, coin_center + cointime_cut_r);


	TCanvas* v2 = new TCanvas();  

	TH1F* hsbeta_check = new TH1F("hsbeta_check", "hsbeta",  400, 0, 2);

	data_tree_in->Draw("hsbeta >> hsbeta_check", all_coin_cut + " && " + coin_cut_str, "goff");

	v2->cd();

	hsbeta_check->GetXaxis()->SetRangeUser(0.85, 1.05);

	hsbeta_check->Draw("hist");

	Double_t hsbeta_max = hsbeta_check->GetMaximum();	

	v2->Update();

	v2->Write("hsbeta_check");

	Double_t hsbeta_center_tmp = hsbeta_check->GetMean();

	// cout << hsbeta_center_tmp << " asdasdas " << endl;

	return hsbeta_center_tmp;

}




/*--------------------------------------------------*/
/*--------------------------------------------------*/

Analysis_omega::~Analysis_omega() {

	delete chain;
	
	delete list;

	delete file_out_ana;

	delete graph_yield_check;

	delete mm_peak_check;

 	delete run_tree;

 	delete tree_out;

// 	delete diamond_cut;
// 
// 	delete diamond_cut_160;
// 
// 	delete diamond_cut_245;
// 
}



	
/*--------------------------------------------------*/
/*--------------------------------------------------*/
/// Output the overall diamond plot for the setting

void Analysis_omega::Overall_Dia_Plot() {

	TCanvas* dia_canva = new TCanvas();

	dia_canva->Update();

	diamond_setting->SetName("diamond_gr");
		
	diamond_setting->Draw("AP");
//	diamond_setting_cut->Draw("P");

	// cout << "  " << diamond_setting_cut->GetListOfGraphs()->GetSize() << endl; 
	// diamond_setting_cut->GetListOfGraphs()->ls();
	// diamond_setting_cut->GetListOfGraphs()->Dump();
	// diamond_setting_cut->GetListOfGraphs()->Print();

	TList * graph_list = diamond_setting->GetListOfGraphs();
 	TIter next(graph_list);
 	TObject* object = 0;
	Int_t event_num = 0;

 	while ((object = next()))
 	{
		event_num = event_num + ((TGraph*)object)->GetN();
 	}


// 	TList * graph_list_cut = diamond_setting_cut->GetListOfGraphs();
//  	TIter next_cut(graph_list_cut);
//  	TObject* object_cut = 0;
// 	Int_t event_num_cut = 0;
// 
//  	while ((object_cut = next_cut()))
//  	{
// 		event_num_cut = event_num_cut + ((TGraph*)object_cut)->GetN();
//  	}
// 





//	cout << "  fsafdsf  " << event_num << endl;

 	TText* number_points = new TText();
 	number_points->SetTextSize(0.035);

 	TString points_str; 
//  	points_str.Form("Total Events: %i", event_num + event_num_cut);
//  	number_points->DrawTextNDC(0.7, 0.85, points_str);
 
 	points_str.Form("Black Events: %i", event_num);
 	number_points->DrawTextNDC(0.7, 0.75, points_str);

//  	points_str.Form("Red Events: %i", event_num_cut);
//  	number_points->DrawTextNDC(0.7, 0.65, points_str);
// 



	diamond_cut->Draw("Lsame");


 	dia_canva->Update();
 	dia_canva->Write("diamand");

	delete number_points;
	delete dia_canva;



}

